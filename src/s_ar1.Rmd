---
title: "Autoregressive example"
output: html_notebook
---

```{r}
rm(list=ls())
library(tidyverse)
library(reshape2)
library(rstan)
library(latex2exp)
library(caret)
library(gbm)
library(mvtnorm)
options(mc.cores=4)
rstan_options(auto_write = TRUE)
source("monitornew.R")
source("r_star_monitor.R")
```

Functions to generate simulated data
```{r}
f_ar1 <- function(rho, sigma, L){
  x <- vector(length = L)
  x[1] <- rnorm(1, 0, sd=sigma)
  for(i in 2:L)
    x[i] = rho * x[i - 1] + rnorm(1, 0, sd=sigma)
  return(x)
}

# Generates three chains with same var; one with a different var
f_generate_lower_var_four <- function(var_ratio, rho, sigma, L){
  x <- matrix(nrow = L, ncol = 4)
  for(i in 1:3)
    x[, i] <- f_ar1(rho, sigma, L)
  z <- f_ar1(rho, sigma * sqrt(var_ratio), L)
  x[, 4] <- z
  return(x)
}
```

Calculate R* and Rhat across 1000 replicates
```{r}
f_replicate <- function(){
  temp <- f_generate_lower_var_four(1/3, 0.3, 1, 1000)
  a_array <- array(dim=c(1000, 4, 1))
  a_array[,,1] <- temp
  a_accuracy <- r_star(a_array)
  mon <- monitor(temp)
  return(list(r_star=a_accuracy, r_hat=mon$Rhat))
}

nreplicates <- 1000
r_star_vals <- vector(length = nreplicates)
r_hat_vals <- vector(length = nreplicates)
for(i in 1:nreplicates){
  if(i%%100==0)
    print(i)
  
  temp <- f_replicate()
  r_star_vals[i] <- temp$r_star
  r_hat_vals[i] <- temp$r_hat
}

saveRDS(tibble(r_star=r_star_vals, r_hat=r_hat_vals), "../data/ar1_r_star_hat.rds")
```

Plot results
```{r}
g2 <- tibble(accuracy=r_star_vals, iteration=seq(1, nreplicates, 1)) %>% 
  ggplot(aes(x=accuracy)) +
  geom_histogram() +
  xlab(TeX("$R*$")) +
  ylab("Count") +
  ggtitle("B.") +
  theme(text = element_text(size=14, colour="black")) +
  xlim(0.9, NA)

g2a <- tibble(accuracy=r_hat_vals, iteration=seq(1, nreplicates, 1)) %>% 
  ggplot(aes(x=accuracy)) +
  geom_histogram() +
  xlab(TeX("split-$\\hat{R}$")) +
  ylab("Count") +
  ggtitle("C.") +
  theme(text = element_text(size=14, colour="black")) +
  xlim(1, NA)
```

Look at predictions of model
```{r}
# add in a column of noise since gbm requires >1 variables
full_data <- f_generate_lower_var_four(1/3, 0.3, 1, 1000) %>% 
  melt() %>% 
  select(-Var1) %>% 
  rename(chain=Var2) %>% 
  mutate(ran_val=rnorm(4000)) %>% 
  mutate(chain=as.factor(chain))

caretGrid <- expand.grid(interaction.depth=c(3), n.trees = 50,
                   shrinkage=c(0.1),
                   n.minobsinnode=10)

rand_samples <- sample(1:nrow(full_data), 0.7 * nrow(full_data))
training_data <- full_data[rand_samples, ]
testing_data <- full_data[-rand_samples, ]
gbmFit1 <- train(chain ~ ., data = training_data, 
                 method = "gbm",
                 trControl = trainControl(method = 'none'), 
                    tuneGrid = caretGrid, verbose=FALSE)

g1 <- testing_data %>% 
  arrange(value) %>% 
  mutate(predictions=predict(object=gbmFit1, .)) %>% 
  ggplot(aes(x=value, y=predictions)) +
  geom_jitter(height = 0.3) +
  xlab("Value") +
  ylab("Chain classification") +
  theme(text = element_text(size=14, colour="black")) +
  coord_flip() +
  ggtitle("A.")
```


Generate R* distribution based on 1000 iterations for run where chain has lower variance and another where all four chains have same variance
```{r}
temp <- f_generate_lower_var_four(1/3, 0.3, 1, 1000) 
temp1 <- matrix(rnorm(4000), nrow = 1000)
a_array <- array(dim=c(1000, 4, 2))
a_array[,,1] <- temp
a_array[,,2] <- temp1
unmixed <- r_star_dist(a_array)

temp <- f_generate_lower_var_four(1, 0.3, 1, 1000)
temp1 <- matrix(rnorm(4000), nrow = 1000)
a_array <- array(dim=c(1000, 4, 2))
a_array[,,1] <- temp
a_array[,,2] <- temp1
mixed <- r_star_dist(a_array)

mAR1 <- tibble(unmixed, mixed)
g3 <- 
  mAR1 %>% 
  melt() %>% 
  ggplot(aes(x=value, fill=as.factor(variable))) +
  geom_histogram(position="identity", alpha=0.8) +
  scale_fill_grey("Series", labels=c("un-mixed", "mixed")) +
  xlab(TeX("$R*$")) +
  ylab("Count") +
  geom_vline(xintercept = 1, linetype=2) +
  ggtitle("D.") +
  theme(text = element_text(size=14, colour="black"),
        legend.position = c(0.8, 0.8))

pdf("../output/ar1.pdf", width = 12, height = 6)
multiplot(g1, g2a, g2, g3, cols = 2)
dev.off()
```